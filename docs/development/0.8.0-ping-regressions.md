# 0.8.0 Ping/Bufferbloat Regressions (2025-11-19)

Context and notes while chasing the new event-driven ping refactor. Command used:

```
SWIFTPM_MODULECACHE_PATH=.build/swiftpm-modulecache \
CLANG_MODULE_CACHE_PATH=.build/clang-modulecache \
PTR_SKIP_STUN=1 swift test -c debug --disable-sandbox
```

## Failing coverage from the run
- **PingIntegrationTests**: `testPingReachableHost`, `testConcurrentPings` all recorded `received == 0` against 1.1.1.1/8.8.8.8/9.9.9.9.
- **InterfaceBindingTests**: `testPingWithOperationInterfaceOverride`, `testPingWithNilGlobalAndOperation`, `testPingWithOperationInterfaceOverride` (multi-interface) timed out even when interfaces were detected (en0/en18).
- **BufferbloatTests**: `testBufferbloatQuickTest` returned zero samples in both baseline and load; RPM assertions failed; `testBufferbloatZeroDurationLoad` baseline sample count was 0.
- **PingParallelismTests**: `testConcurrentPingsAreParallel` reported parallelism factor ~88x (2.91s elapsed with ~33ms RTTs).
- **MultipathTests**: `testMultipathBatchesFinishNearTimeoutBudget` elapsed 5.89s vs expectation <5s (likely fallout from ping stalls).

## Observations
- The bufferbloat comparison helper showed en0 getting 0 samples while en18 succeeded in the same process, hinting at per-socket demux rather than actual network loss.
- Parallel ping test printed 20 RTTs (~32–33ms) yet still took 2.91s and flagged as serialized, implying some sockets timed out while others received replies.
- Multiple suites run concurrently under `swift-testing`, so ping sockets from different tests are active at the same time.

## Hypothesis
The ping refactor now builds ICMP echo requests with **identifier = 0** and `parsePingMessage` ignores identifiers entirely (“let kernel handle ID”). On macOS ICMP `SOCK_DGRAM`, the kernel demuxes replies by ICMP identifier. With every socket using id 0, replies can land on an arbitrary socket; most operations never see their responses and time out. Ignoring identifiers in the parser also allows cross-contamination when multiple sockets do receive packets.

This explains:
- Zero responses despite a healthy network.
- Highly inflated parallelism factor (timeouts instead of fast completion).
- Bufferbloat baselines returning 0 samples when another socket consumed the replies.

## Next steps / fixes to try
1) Restore per-socket unique identifier generation (reuse 0.7.0’s `generateIdentifier()` with PID xor + counter) and embed it in `makeICMPEchoRequest`.
2) Teach `parsePingMessage` to validate the expected identifier for Echo Reply and the embedded identifier inside Time Exceeded / Dest Unreachable before recording.
3) Re-run the same test command to confirm ping, bufferbloat, interface binding, and parallelism suites recover, then revisit the Multipath timeout assertion.

## 2025-11-19 follow-up (after identifier fix)
- Implemented unique identifiers + parser validation and reran:
  - Filtered runs (`PingIntegration`, `PingParallelism`, `Bufferbloat`) all pass.
  - Full `swift test -c debug --disable-sandbox` now reduced to 7 issues:
    - PingIntegration: `testPingReachableHost`, `testConcurrentPings` (0 replies while other network-heavy suites ran).
    - Multipath: `testMultipathPerformanceIsReasonable` (~7.9s vs <6s) and `testMultipathBatchesFinishNearTimeoutBudget` (~7.8s vs <5s).
  - Ping flakiness appears only in the fully concurrent runner; isolated runs are clean, suggesting cross-test interference (bufferbloat comparison and other load-heavy suites overlapping).
- Next focus: isolate/serialize the heavy suites to avoid interference, then profile multipath deadlines with the corrected ping path.

## 2025-11-19 (pool contention check)
- Removed heuristic relaxations; kept assertions intact.
- Observed remaining flakiness (bufferbloat baseline zero samples, DNS probe RTT > 5s) when many suites run in parallel. Prior root-cause incident in 0.7.x was thread-pool exhaustion during `poll()` use; new GCD path should still avoid main-thread blocking but may contend when tests overlap.
- Need a deterministic reproduction of contention: run heavy suites serially (or with 1 worker) to see if failures disappear without relaxing thresholds. If yes, pursue explicit test serialization rather than loosening expectations.

## 2025-11-19 (final pass)
- Added `NetworkTestGate` and applied it to network-heavy suites (ping integration/parallelism, bufferbloat, interface binding, probes, multipath) to serialize live-network tests and avoid cross-suite interference.
- Hardened interface selection in BufferbloatComparison and InterfaceBinding to require active IPv4 and reachable ping before use.
- Swapped HTTP probe fixtures to stable httpbingo endpoints.
- Full `swift test -c debug --disable-sandbox` now **passes all tests** (122 tests, 0 failures).

## 2025-11-20 (suite pass with gate timing fix)
- Moved the Bufferbloat baseline timing start inside `NetworkTestGate.withPermit` to exclude queue wait time from the elapsed calculation (was inflating `testBufferbloatBaselineSpeed` when other gate users were running).
- Re-ran the full suite to verify actor scheduling and parallelism after the change:
  - Command: `PTR_SKIP_STUN=1 swift test -c debug --disable-sandbox`
  - Result: 122 tests, 0 failures. ActorSchedulingTests and BufferbloatTests now pass consistently.
